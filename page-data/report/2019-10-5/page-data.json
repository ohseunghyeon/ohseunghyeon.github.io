{"componentChunkName":"component---src-templates-blog-post-js","path":"/report/2019-10-5/","webpackCompilationHash":"c5fbdcfd737f3fb37edf","result":{"data":{"site":{"siteMetadata":{"title":"Lazy Nyaong","author":"Oh SeungHyeon"}},"markdownRemark":{"id":"76f78726-a556-54b3-bd05-cde7be9ac236","excerpt":"Rendering on the Web 웹에서 렌더링하는 다양한 방법들의 특징 및 비교 infographic showing the server-client spectrum 관련 영상: Rendering on the Web: Performance Implications of…","html":"<h2 id=\"rendering-on-the-web\"><a href=\"#rendering-on-the-web\" aria-label=\"rendering on the web permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://developers.google.com/web/updates/2019/02/rendering-on-the-web#server-rendering\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rendering on the Web</a></h2>\n<p>웹에서 렌더링하는 다양한 방법들의 특징 및 비교</p>\n<p><img src=\"https://developers.google.com/web/updates/images/2019/02/rendering-on-the-web/infographic.png\" alt=\"infographic showing the server-client spectrum\"></p>\n<p>관련 영상: <a href=\"https://www.youtube.com/watch?v=k-A2VfuUROg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rendering on the Web: Performance Implications of Application Architecture (Google I/O ’19)</a></p>\n<h2 id=\"prpl-패턴-addy-osmani\"><a href=\"#prpl-%ED%8C%A8%ED%84%B4-addy-osmani\" aria-label=\"prpl 패턴 addy osmani permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">PRPL 패턴, Addy Osmani</a></h2>\n<p>점차 인터넷을 사용하는 디바이스 중 모바일이 차지하는 비율이 늘어감에 따라, 모바일 웹 앱의 경험을 향상시키기 위한 목적으로 탄생한 PWA를 구성하고 제공하기 위한 패턴.</p>\n<ul>\n<li>Push: 초기 URL 경로에서 중요한 리소스를 푸시합니다.</li>\n<li>Render: 초기 경로를 렌더링합니다.</li>\n<li>Pre-cache: 남은 경로를 사전 캐시합니다.</li>\n<li>Lazy-load: 필요 시 남은 경로를 지연 로드하고 생성합니다.</li>\n</ul>\n<h2 id=\"caching-in-react\"><a href=\"#caching-in-react\" aria-label=\"caching in react permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://freecontent.manning.com/caching-in-react/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Caching in React</a></h2>\n<p>in memory 캐싱, redis를 사용한 캐싱, CDN을 사용한 캐싱에 대한 특징과 간단한 구현 방법을 서술한 글</p>\n<p><a href=\"/study/caching-in-react/\">번역</a></p>\n<h2 id=\"a-comprehensive-guide-to-http2-server-push-jeremy-wagner-2017410\"><a href=\"#a-comprehensive-guide-to-http2-server-push-jeremy-wagner-2017410\" aria-label=\"a comprehensive guide to http2 server push jeremy wagner 2017410 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">A comprehensive guide to HTTP/2 Server Push, Jeremy Wagner, 2017.4.10</a></h2>\n<p>HTTP/2가 지원하는 Server push에 대한 글</p>\n<h3 id=\"summary\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>summary</h3>\n<p>HTTP/2 이전에는 브라우저가 어떤 페이지를 요청했을 때, index.html을 우선 받고, 이를 파싱하면서 css와 javascript 파일을 따로 요청해야 했다. 그러나 HTTP/2가 지원하는 Server push를 사용하면, 클라이언트가 index.html을 요청했을 때 서버가 알아서 index.html와 style.css 등 여타 파일을 함께 응답해줄 수 있다. 추가적인 요청을 줄여서 이는 브라우저가 더 빠르게 화면을 그릴 수 있게 된다는 뜻이다.</p>\n<h3 id=\"장점\"><a href=\"#%EC%9E%A5%EC%A0%90\" aria-label=\"장점 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>장점</h3>\n<ul>\n<li>Round trip을 줄여준다.</li>\n<li>anti pattern인 inline css, javascript와 <a href=\"https://en.wikipedia.org/wiki/Data_URI_scheme\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">data URI scheme</a>의 대안으로 적절하다. (inline css와 javascript 등은 모듈화가 되지 않아 다른 페이지에서 이 내용이 필요할 경우 캐시되지 않는다.)</li>\n</ul>\n<h3 id=\"성능\"><a href=\"#%EC%84%B1%EB%8A%A5\" aria-label=\"성능 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능</h3>\n<p>해당 기사에서는 CSS만 server push했을 때 성능이 제일 좋았다. javascript와 기타 등등의 파일을 같이 push했을 때 되려 화면이 그려지는 속도가 느렸다.</p>\n<p>2017년 글임을 감안하여 최근엔 브라우저가 이를 어떻게 최적화했을지 모르므로, 좀 더 자료를 찾아보거나 직접 벤치마킹하여 서버푸쉬를 사용해야 할 것 같다.</p>\n<h3 id=\"server-push와-cache\"><a href=\"#server-push%EC%99%80-cache\" aria-label=\"server push와 cache permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>server push와 cache</h3>\n<p>서버가 무조건 어떤 데이터를 보내준다면, 재방문 사용자이고 캐시를 가지고 있을 경우 캐시를 무시하는 결과를 낳게 된다. 이에 관하여, 클라이언트상의 쿠키로 캐시가 있으니 서버푸쉬를 보내지 않아도 되게끔 하는 기능을 가진 솔루션(cache-aware server push mechanism)\n이 있으니 참고하는 것이 좋을 것 같다.</p>\n<h2 id=\"http2-소개\"><a href=\"#http2-%EC%86%8C%EA%B0%9C\" aria-label=\"http2 소개 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://developers.google.com/web/fundamentals/performance/http2/#server-push\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">HTTP/2 소개</a></h2>\n<h3 id=\"바이너리-프레이밍-계층\"><a href=\"#%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC-%ED%94%84%EB%A0%88%EC%9D%B4%EB%B0%8D-%EA%B3%84%EC%B8%B5\" aria-label=\"바이너리 프레이밍 계층 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>바이너리 프레이밍 계층</h3>\n<p>바이너리 프레이밍 계층은 HTTP 메시지를 캡슐화하여 클라이언트와 서버 사이에 전송되는 방식을 규정한다. 이 계층을 통해 동일한 연결에서 다중 동시 교환이 가능하다. 이렇게 한 연결에서 다중화된 요청과 응답이 가능하기 때문에 HOLB(Head of Line Blocking)<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>이 발생하지 않는다.</p>\n<h3 id=\"스트림-우선순위-지정\"><a href=\"#%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%A7%80%EC%A0%95\" aria-label=\"스트림 우선순위 지정 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스트림 우선순위 지정</h3>\n<p>각 스트림의 종속성, 우선순위를 지정할 수 있으나 실제로 이게 서버에 강제되지는 않는다. 즉, 안 지켜질 수 있다는 뜻.</p>\n<h3 id=\"출처당-하나의-연결\"><a href=\"#%EC%B6%9C%EC%B2%98%EB%8B%B9-%ED%95%98%EB%82%98%EC%9D%98-%EC%97%B0%EA%B2%B0\" aria-label=\"출처당 하나의 연결 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처당 하나의 연결</h3>\n<p>TCP 연결이 하나만 있으면 충분하다. 동일한 연결을 재사용하여 각 TCP 연결을 더 효율적으로 사용할 수 있다. 이는 전체 네트워크의 자원의 효율성도 높여준다. 또한 TLS 핸드셰이크도 줄고 세션의 재사용이 더 향상되어 클라이언트와 서버의 리소스도 감소한다.</p>\n<!-- ### 흐름제어 -->\n<h3 id=\"서버-푸시\"><a href=\"#%EC%84%9C%EB%B2%84-%ED%91%B8%EC%8B%9C\" aria-label=\"서버 푸시 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버 푸시</h3>\n<p>서버가 단일 클라이언트 요청에 대해 여러 응답을 보낼 수 있다. 서버는 어떤 리소스가 클라이언트에 필요한지 이미 알고 있다. 지연 시간을 줄이기 위해 서버가 리소스를 미리 푸시하는 것.</p>\n<p>서버 푸시는 PUSH<em>PROMISE 프레임을 통해 시작되며, 해당 프레임에 어떤 리소스가 푸시될 것인지 기술된다. 클라이언트는 이 프레임을 받고 어떤 리소스가 이미 캐시된 경우 RST</em>STEAM 프레임을 통해 이를 거부할 수 있다.</p>\n<p>클라이언트는 서버 푸시에 대한 완벽한 제어를 할 수 있어서, 서버 푸시 스트림의 수 제한, 푸시되는 데이터 크기를 제어하는 초기 흐름 제어 창 조정, 서버 푸시 비활성화를 할 수 있다.</p>\n<!-- ### 헤더 압축 -->\n<h2 id=\"hastening-react-ssr-with-component-memoization-and-templatization\"><a href=\"#hastening-react-ssr-with-component-memoization-and-templatization\" aria-label=\"hastening react ssr with component memoization and templatization permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://speakerdeck.com/maxnajim/hastening-react-ssr-with-component-memoization-and-templatization?slide=26\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Hastening React SSR with component memoization and templatization</a></h2>\n<p>리액트 서버 사이드 렌더링 시 메모이제이션 패턴을 어떻게 적용하는 것에 대한 발표 슬라이드 자료</p>\n<h2 id=\"how-typescript-can-power-design-systems--isha-kasliwal--jsconf-korea-2019\"><a href=\"#how-typescript-can-power-design-systems--isha-kasliwal--jsconf-korea-2019\" aria-label=\"how typescript can power design systems  isha kasliwal  jsconf korea 2019 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.youtube.com/watch?v=hbsIOHktvfo&#x26;list=PL37ZVnwpeshGanWnYhTdoFLM2IDF28MaQ\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How Typescript Can Power Design Systems | Isha Kasliwal | JSConf Korea 2019</a></h2>\n<p>Workflow by Design System</p>\n<ol>\n<li>Ideation</li>\n<li>Design</li>\n<li>Code</li>\n<li>Production</li>\n</ol>\n<p>why typescript?</p>\n<p>타입스크립트로 개발하는 것은 인터페이스 중심의 개발이다. 디자이너와 개발자 모두 이런 인터페이스에 쉽게 접근할 수 있고, 그로 인해 얻는 이점들이 많다.</p>\n<p>이 동영상은 타입스크립트보다는 디자인시스템에 대한 내용인 것 같다.</p>\n<h2 id=\"dont-block-the-event-loopjavascript-async-for-effortless-uxjaeseok-kangjsconf-korea-2019\"><a href=\"#dont-block-the-event-loopjavascript-async-for-effortless-uxjaeseok-kangjsconf-korea-2019\" aria-label=\"dont block the event loopjavascript async for effortless uxjaeseok kangjsconf korea 2019 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><a href=\"https://www.youtube.com/watch?v=c7C8IcRqUUg&#x26;list=PL37ZVnwpeshGanWnYhTdoFLM2IDF28MaQ&#x26;index=4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Don’t block the event loop!JavaScript Async for Effortless UX|Jaeseok Kang|JSConf Korea 2019</a></h2>\n<p>자바스크립트는 기본적으로 단일 콜스택과 이벤트 루프로 동작한다. 그로 인해 고연산의 작업을 진행할 때 다른 작업을 아예 할 수 없게 된다. 이를 해결할 수 있는 몇 가지 방법을 소개하는 영상이다.</p>\n<ul>\n<li>worker thread</li>\n<li>scheduling (큰 작업을 쪼개서 짧게 짧게 동작하게)</li>\n<li>DOM 갱신 최적화 (이벤트가 여럿이 연속적으로 발생 시 마지막 작업만 실행)</li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>HTTP/2 이전에는 하나의 여러 요청이 서버로 들어올 경우 이를 순서대로 처리해야 했다. 즉 어떤 요청에 대한 응답의 크기가 클 경우 이를 처리하기 위해 다른 응답은 기다려야 했는데, HTTP/2에서는 한 TCP 연결 내에서 스트림 별로 다중화하기 때문에 기다릴 필요가 없다.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","tableOfContents":"<ul>\n<li><a href=\"/report/2019-10-5/#rendering-on-the-web\">Rendering on the Web</a></li>\n<li><a href=\"/report/2019-10-5/#prpl-%ED%8C%A8%ED%84%B4-addy-osmani\">PRPL 패턴, Addy Osmani</a></li>\n<li><a href=\"/report/2019-10-5/#caching-in-react\">Caching in React</a></li>\n<li>\n<p><a href=\"/report/2019-10-5/#a-comprehensive-guide-to-http2-server-push-jeremy-wagner-2017410\">A comprehensive guide to HTTP/2 Server Push, Jeremy Wagner, 2017.4.10</a></p>\n<ul>\n<li><a href=\"/report/2019-10-5/#summary\">summary</a></li>\n<li><a href=\"/report/2019-10-5/#%EC%9E%A5%EC%A0%90\">장점</a></li>\n<li><a href=\"/report/2019-10-5/#%EC%84%B1%EB%8A%A5\">성능</a></li>\n<li><a href=\"/report/2019-10-5/#server-push%EC%99%80-cache\">server push와 cache</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/report/2019-10-5/#http2-%EC%86%8C%EA%B0%9C\">HTTP/2 소개</a></p>\n<ul>\n<li><a href=\"/report/2019-10-5/#%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC-%ED%94%84%EB%A0%88%EC%9D%B4%EB%B0%8D-%EA%B3%84%EC%B8%B5\">바이너리 프레이밍 계층</a></li>\n<li><a href=\"/report/2019-10-5/#%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%A7%80%EC%A0%95\">스트림 우선순위 지정</a></li>\n<li><a href=\"/report/2019-10-5/#%EC%B6%9C%EC%B2%98%EB%8B%B9-%ED%95%98%EB%82%98%EC%9D%98-%EC%97%B0%EA%B2%B0\">출처당 하나의 연결</a></li>\n<li><a href=\"/report/2019-10-5/#%EC%84%9C%EB%B2%84-%ED%91%B8%EC%8B%9C\">서버 푸시</a></li>\n</ul>\n</li>\n<li><a href=\"/report/2019-10-5/#hastening-react-ssr-with-component-memoization-and-templatization\">Hastening React SSR with component memoization and templatization</a></li>\n<li><a href=\"/report/2019-10-5/#how-typescript-can-power-design-systems--isha-kasliwal--jsconf-korea-2019\">How Typescript Can Power Design Systems | Isha Kasliwal | JSConf Korea 2019</a></li>\n<li><a href=\"/report/2019-10-5/#dont-block-the-event-loopjavascript-async-for-effortless-uxjaeseok-kangjsconf-korea-2019\">Don’t block the event loop!JavaScript Async for Effortless UX|Jaeseok Kang|JSConf Korea 2019</a></li>\n</ul>","timeToRead":5,"frontmatter":{"title":"2019년 10월 다섯째 주","date":"October 27, 2019","description":"매주 무엇을 읽고 보았는지 정리하는 글","category":"report"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/report/2019-10-5/","previous":{"fields":{"slug":"/report/2019-10-3/"},"frontmatter":{"title":"2019년 10월 셋째 주","category":"report"}},"next":{"fields":{"slug":"/report/2019-11-2/"},"frontmatter":{"title":"2019년 11월 둘째 주","category":"report"}}}}}